		/**
		 * @param fb Freebase build by Freebase.loadFreebase();
		  * @param correctMatches reverb entity -> correct freebase id
		   * @param input output file generated by {@link Mapper}
		    * @param threshold limit of number of matches to search(non-inclusive)
			 * @return percent of matches in input file under given threshold
			  * @throws FileNotFoundException
			   */
			   public static double analyze(Freebase fb, Map<String, String> correctMatches, File input, int threshold, boolean debug) throws FileNotFoundException{
			   		  List<Result> results = Utils.parseOutputFile(input, fb, debug);
					  			   Set<Result> uniqueResults = new HashSet<Result>();
								   			   int numUnderThreshold = 0;
											   	   
														for(Result res : results){
																   	   if(correctMatches.containsKey(res.q.orig) && !uniqueResults.contains(res)){
																														String correctID = correctMatches.get(res.q.orig);
																															   			   if(res.hasMatch(correctID) && res.getDepth(correctID) <= threshold){
																																		   							  	 						 	numUnderThreshold++;
																																																	   }else if(debug){
																																																	   		    System.out.println("Missed: " + res.q.orig);
																																																											  	}
																																																												   uniqueResults.add(res);
																																																												     }
																																																													  }
																																																													   return numUnderThreshold / (double) uniqueResults.size();
																																																													   }

public static void analyze(Freebase fb, Map<String, String> correctMatches, File input) throws IOException{
	   		  List<Result> results = Utils.parseMapperOutputFile(input, fb);
			  			   Set<Result> uniqueResults = new HashSet<Result>();
						   			   
										for(Result res : results){
												   	   if(correctMatches.containsKey(res.q.orig) && !uniqueResults.contains(res)){
																										String correctID = correctMatches.get(res.q.orig);
																											   			   if(res.hasMatch(correctID)){
																														       Entity e = res.getMatch(correctID);
																															   		  	   
																																		       int fbDepth = e.offset + 1;
																																			   	   		   	 		  int resDepth = res.getDepth(correctID);
																																									  	  		   	  
																																													      System.out.println(res.q.orig + "\t" + fbDepth + "\t" + resDepth);
																																														  								  	   }else{
																																																							       System.out.println(res.q.orig + "\t" + Integer.MAX_VALUE + "\t" + Integer.MAX_VALUE);
																																																								   								   		}
																																																																		   
																																																																		      uniqueResults.add(res);
																																																																			    }
																																																																				 }
																																																																				 }


	//USED FOR PERFORMANCE BENCHMARKING
	public long c1 = 0;
	public long c2 = 0;
	public long c3 = 0;
	public long c4 = 0;
	public long c5 = 0;
	
	/**
	 * Resets all timers to 0.
	 */
	public void resetTiming(){
		this.c1 = 0;
		this.c2 = 0;
		this.c3 = 0;
		this.c4 = 0;
		this.c5 = 0;
	}

	/**
	 * @param query entity to search for matches for
	 * @param maxMatches maximum number of matches to return
	 * @param pf used for performance benchmarks
	 * @return {@link Result} containing any matches found
	 */
	public Result getMatches(String query, int maxMatches){
		Result rtn = new Result(query);
		int matches = 0;
		int depth = 0;
		long timer = 0;
		
		for(Entity ent : this){
			depth++;
			timer = System.nanoTime();
			if(this.matches(ent, query, ((double)depth) / this.size())){
				timer = System.nanoTime() - timer;
				
				matches++;
				rtn.add(ent);
				if(maxMatches != -1 && matches == maxMatches)
					break;
			}else{
				timer = System.nanoTime() - timer;
			}
		}
		return rtn;
	}
	
	/**
	 * @param fbEnt entity in Freebase
	 * @param rvEnt entity in Reverb
	 * @param pt current percent of Freebase entities searched
	 * @return true if the two entities match, false otherwise
	 */
	private boolean matches(Entity fbEnt, String rvEnt, double pt){
		boolean rtn = false;
		
		if(this.opt.SUB_AB){
			long start = System.nanoTime();
			rtn = rtn || fbEnt.contents.contains(rvEnt);
			this.c1 += System.nanoTime() - start;
		}
		
		if(this.opt.SUB_BA && !rtn && fbEnt.contents.length() > 1){
			long start = System.nanoTime();
			rtn = rtn || rvEnt.contains(fbEnt.contents);
			this.c2 += System.nanoTime() - start;
		}
		
		if(this.opt.DIST && !rtn){
			long start = System.nanoTime();
			rtn = rtn || Utils.stringDistance(fbEnt.contents, rvEnt, 10) < (fbEnt.contents.length() + rvEnt.length()) / 6 + 1;
			this.c3 += System.nanoTime() - start;
		}
		
		if(this.opt.ACRO_AB && !rtn && pt < 0.2){
			long start = System.nanoTime();
			rtn = rtn || fbEnt.hasAcronym() && Acronym.acrMatch(rvEnt, fbEnt.acronym); //Acronym.cleanAcronym(rvEnt).equals(fbEnt.acronym);
			this.c4 += System.nanoTime() - start;
		}
		
		if(this.opt.ACRO_BA && !rtn){
			long start = System.nanoTime();
			rtn = rtn || Acronym.matches(fbEnt.contents, rvEnt);
			this.c5 += System.nanoTime() - start;
		}
		
		return rtn;
	}